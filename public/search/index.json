[{"content":" TIL - HTML 분석 📋 공부 내용 requests\n라이브러리를 사용해 웹 브라우저와 같이 웹 페이지를 요청하고 응답을 받아옴 응답 받은 문서 -\u0026gt; 분석 필요! BeautifulSoup HTML 코드를 분석 하는 라이브러리 (HTML Parser)\n설치 방법 (mac, python3 기준)\n1 2 3 pip install bs4 or pip3 install bs4 HTML 분석 실습 필요 라이브러리 불러오기\n1 2 import requests from bs4 import BeautifulSoup #import bs library 사이트를 요청하고 응답받기\n1 2 # requests.get으로 사이트 HTML을 받아 와 저장 res = requests.get(\u0026#34;https://www.example.com\u0026#34;) 응답받은 HTML으로 BeautifulSoup 객체를 만들고 내용을 출력해보기\n1 2 3 4 5 6 # bs 객체를 만들고, res.text와 \u0026#34;html.paser\u0026#34;를 인자로 넘겨 # HTML parser 역할을 하게 만듬 soup = BeautifulSoup(res.text, \u0026#34;html.parser\u0026#34;) # HTML의 구조를 잘 보여주도록 들여쓰기하여 출력 print(soup.prettify()) HTML의 특정 요소 찾기\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 해당하는 각 태그의 내용을 보여줌 soup.title soup.head soup.body # h1태그들 중 가장 먼저 나오는것을 찾아 반환 h1 = soup.find(\u0026#34;h1\u0026#34;) # p태그 모두를 찾아 반환 soup.find_all(\u0026#34;p\u0026#34;) # 태그 이름과 (h1) 태그 안의 내용을 가져옴 h1.name h1.text 특정 요소를 찾아 그 안의 원하는 정보만 추려내기\n1 2 3 4 5 6 7 8 9 # 책 리스트를 찾아 그 제목만 추출하는 코드 # 직접 사이트를 확인하고 h3태그에 책 이미지, 저자, 제목 등이 있는것을 확인하여 find_all로 가져옴 h3_results = soup.find_all(\u0026#39;h3\u0026#39;) # 객체로 만들게 되면, 내부 태그를 속성처럼 쓸 수 있음 # h3 \u0026gt; a 태그 내에 title 속성 value를 출력하는 함수 for book in h3_results: print(book.a[\u0026#39;title\u0026#39;]) id를 이용해 요소 가져오기\n1 2 3 # .find(\u0026lt;tag_name\u0026gt;, id = \u0026lt;id_name\u0026gt;) soup.find_all(\u0026#34;div\u0026#34;, id=\u0026#34;bo_list\u0026#34;) soup.find(\u0026#34;div\u0026#34;, id=\u0026#34;bo_cate\u0026#34;) class를 이용해 요소 가져오기\n1 2 3 # .find(\u0026lt;tag_name\u0026gt;, \u0026lt;class_name\u0026gt;) soup.find_all(\u0026#34;li\u0026#34;, \u0026#34;questions\u0026#34;) soup.find(\u0026#34;div\u0026#34;, \u0026#34;question\u0026#34;) user-agent 정보를 넘기면서 요청하기\nuser agent 확인 사이트\n1 2 3 4 5 user_agent = {\u0026#34;User-Agent\u0026#34;: \u0026lt;본인의 user agent 정보\u0026gt;} import requests from bs4 import BeautifulSoup url = \u0026#34;https://qna.programmers.co.kr/\u0026#34; res = requests.get(url, user_agent) 페이지네이션 (Pagination)\n정보를 인덱스로 구분하는 기법\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 해당 사이트는 query string으로 구분 import time import requests from bs4 import BeautifulSoup url = \u0026#34;https://qna.programmers.co.kr/?page={}\u0026#34; for i in range(1, 6): res = requests.get(url.format(i), user_agent) soup = BeautifulSoup(res.text, \u0026#34;html.parser\u0026#34;) questions = soup.find_all(\u0026#34;li\u0026#34;, \u0026#34;question-list-item\u0026#34;) for question in questions: print(question.find(\u0026#34;div\u0026#34;, \u0026#34;question\u0026#34;).find(\u0026#34;div\u0026#34;, \u0026#34;top\u0026#34;).h4.a.text) # 과도한 요청을 방지하기 위해 1초마다 요청 time.sleep(1) 웹 사이트와 스크래핑 정적 or 동적 웹 사이트 웹 사이트는 정적(Static) 웹 사이트 와 동적(Dynamic) 웹 사이트 로 나눌 수 있다. 웹 사이트 Static Dynamic HTML 내용 고정 변경 HTML 데이터 로드 응답 이전에 완료됨 응답 이후에 완료되기도 함 동기 or 비동기 처리 동기 처리 (정적 웹 사이트)\n렌더링이 완료된 이후에 데이터 처리를 진행 요청에 따른 응답을 기다려야 함 비동기 처리 (동적 웹 사이트)\n렌더링과 데이터 처리가 동시에 진행됨 요청에 따른 응답을 기다리지 않음 상황에 따라 응답 시 받은 HTML 문서의 데이터가 완전하지 않은 경우 발생 스크래핑 requests 요청의 문제점\n불완전하고 원하지 않은 내용의 응답을 받게 되어 동적 웹사이트에 적용이 어려움 키보드, 마우스 입력 등 UI와 상호작용 하기 어려움 해결 방법\n데이터 처리 후 응답을 받아오는 방식 적용 UI Action을 프로그래밍 웹 브라우저 역할을 하는 대신 웹 브라우저를 조작 -\u0026gt; Selenium 👀 CHECK (어렵거나 새롭게 알게 된 것 등 다시 확인할 것들)\nPagination : 정보를 인덱스로 구분하는 기법 Query String .format method 1 \u0026#34;{}\u0026#34;.format(a) -\u0026gt; \u0026#34;a\u0026#34; 동기 처리와 비동기 처리의 개념에 대해 한번 더 복습 bs .find 함수 여러 요소를 찾을 때 or을 적용하여 A or B or C class 모두를 찾을 수 있는지 궁금 class A, B / class A 인 요소 두 개가 있을 때 class B를 가진 요소는 배제하고 찾는 방법도 궁금 정적 웹 사이트에는 requests같은 라이브러리를 쓰고 동적 웹 사이트에는 Selenium을 쓰는지 아니면 일괄적으로 Selenium처럼 웹 사이트를 조작하는 형식의 라이브러리만 쓰는지 궁금하다. 중첩된 div 내에 h4가 있는 경우에 (div\u0026gt;div\u0026gt;h4) 가장 바깥 div 내에 h4가 하나뿐이라면 div_container.find(\u0026quot;div\u0026quot;).h4 로 쓰지 않고 div_container.h4로 작성해도 원하는 기능을 하던데 이유가 궁금하다. ❗ 느낀 점 오늘은 꽤나 만족스러운 하루를 보냈다.\n강의와 실습은 내 기준엔 어렵지 않아 2시간 내로 완료했다. 실습을 하면서 주어진 사이트 외에 다른 사이트도 들어가서 분석하고 배운 함수를 적용해보았다. 실습을 하면서 궁금한 점이 몇개 생겼고 CHECK에도 적어놨는데, TIL을 다 적은 후에 구글링 및 슬랙 채널을 통해서 해결해 볼 생각이다.\n그리고 코어타임 중간에 hugo로 만든 블로그에 글을 올려봤는데 내가 생각했던것 보다 더 쉬워서 안심했다. 블로그와 관련해 다음 세 가지 목표를 세웠다.\ngithub action 수정해서 push 하면 자동으로 빌드, 배포되게 만들기 hugo new post 템플릿 만들기 한국어 설정하기 이렇게 세팅을 완료한 후에, 기존에 작성했던 TIL을 올리고 카테고리 설정까지 하면 완성이다. 나중엔 블로그 메인 페이지 커스텀, 댓글 위젯 설정, SEO 세팅 등을 해보려고 한다.\n","date":"2023-10-25T16:23:38+09:00","permalink":"https://srlee056.github.io/p/day-8/","title":"Day 8"},{"content":"TIL - HTTP 📋 공부 내용 웹 웹 페이지와 HTML 웹 페이지\n웹 속의 문서 하나 ex) 네이버 메인 페이지 HTML으로 구성되어있음 웹 사이트\n여러 웹 페이지의 모음 ex) 네이버라는 웹 사이트 웹 브라우저\nHTTP요청을 보낸 후, HTTP응답에 담긴 HTML문서를 사용자가 보기 쉽게 화면으로 그려주는 (렌더링) 역할 HTML(개념 정리 글 링크)\n이전 강의에서 다룬 내용 참고 웹 브라우저마다 지원하는 태그와 속성이 달라짐 웹 스크래핑 / 웹 크롤링 웹 스크래핑\n특정 목적에 따라 웹 페이지에서 원하는 데이터를 \u0026ldquo;추출\u0026rdquo; ex) 날씨 정보 가져오기, 주식 데이터 가져오기, \u0026hellip; 웹 크롤링\n크롤러를 이용해 URL을 타고 이동하며 반복적으로 웹 페이지의 데이터를 가져와 \u0026ldquo;인덱싱\u0026rdquo;(데이터 색인) 구글, 네이버 등 검색 엔진의 웹 크롤러 올바른 HTTP Request 올바른 HTTP Request를 위해선..\n어떤 목적을 달성하려 하는가? 서버에 영향을 미치는가? 로봇 배제 프로토콜(REP)\n웹 크롤링, 스크래핑은 로봇에 의해 실행 가능 사이트의 모든 정보를 취득하는것이 정당한가? 의문에서 시작 robots.txt 각 사이트마다 허용하는 크롤러 정보와 허용범위에 대한 정보를 담고 있음 User-agent, Disallow, Allow HTTP HTTP? HyterText Transfer Protocol\n웹 상에서 정보를 주고받기 위한 약속\nHTTP Request HTTP Response 방향 Client -\u0026gt; Server Client \u0026lt;- Server 역할 정보 요청 요청에 대한 내용을 담은 응답 HEAD method, path, \u0026hellip; content-type, date, \u0026hellip; BODY document 통신하기 requests\nPython으로 HTTP 통신을 진행할 수 있게 해주는 라이브러리 GET\nnaver 메인 페이지를 요청하는 코드 1 2 3 4 import requests res = requests.get(\u0026#34;https://www.naver.com\u0026#34;) # HTTP Response res.headers # Header 확인 res.text # Body(document) text 형태로 확인 POST\nhttps://webhook.site 를 통해 POST 통신을 진행할 수 있음 1 2 3 4 payload = {\u0026#34;name\u0026#34;: \u0026#34;Hello\u0026#34;, \u0026#34;age\u0026#34;: 13} url = \u0026#34;https://webhook.site/\u0026lt;개인 주소\u0026gt;\u0026#34; res = requests.post(url, payload) res.status_code # 상태 코드 확인 DOM DOM? Document Object Model\nHTML을 파싱하여, 브라우저가 이해하도록 만든 Tree형태의 자료구조\nDOM의 각 노드를 객체로 생각하여, 문서를 편리하게 관리할 수 있음\n원하는 요소를 동적으로 변경할 수 있음\n원하는 요소를 쉽게 찾을 수 있음\npython으로 HTML을 직접 분석하려면 DOM을 생성해주는 브라우저를 거치지 않기 때문에, 직접 HTML을 분석하는 HTML Parser가 필요\n👀 CHECK (어렵거나 새롭게 알게 된 것 등 다시 확인할 것들)\nJupyter lab\nJupyter notebook이나 Colab은 써 봤는데 Jupyter lab은 처음 접해봄 Jupyter notebook과 비슷하지만 더 개선된 버전(?) DOM에 대한 설명 및 활용 : 복습 후 다른 예시들을 더 찾아볼 것\n❗ 느낀 점 HTML 스크래핑을 해본적이 있어서 이론이나 실습 모두 빠르게 진행했다. 5시간 분량의 강의인데 3시간 내로 끝난 것 같다. TIL을 잘 적고 싶어서 고민을 좀 했고 그 외의 시간은 평소보다는 널널하게 흘려보냈다.\nTIL을 적을 때 기존에는 강의 받아쓰기처럼 적는 경향이 있었는데, 나중에 다시 읽어보니 이해하고 쓴 것 같은 느낌이 전혀 들지 않았다. 어제 HTML이론에 대한 TIL은 실습 부분 외에도 직접 사용해보고 하면서 적은거라, \u0026lsquo;내가 직접 써보고 이해한 내용\u0026rsquo;임을 알 수 있었다. 그런데 초반에 적은 TIL을 다시 보니까 그냥 받아적은게 티가 나기도 하고 잘 기억이 나지 않았다.\n오늘은 강의를 처음부터 끝까지 들은 후 키워드만 체크해 필기한 다음, TIL을 적으면서 중간중간 다시 듣는 방식을 사용했다. 이 방식으로 더 잘 읽히고 짜임새 있는 구성의 글을 쓰게 되어서 만족스러웠다. TIL 쓰는 시간은 오래 걸리지만 익숙해지면 줄어들 것 같아서 걱정은 되지 않는다.\n커리큘럼을 보니 내일부터는 BeautifulSoup를 사용해 스크래핑을 시작하는데, 모르는 부분이 많을 것 같아 벌써부터 기대가 된다. :\u0026gt;\n","date":"2023-10-24T00:00:00Z","permalink":"https://srlee056.github.io/p/day-7/","title":"Day 7"},{"content":" TIL - HTML 📋 공부 내용 HTML\nHypertext Markup Language\n웹 브라우저가 이해할 수 있는 \u0026ldquo;언어\u0026rdquo;\nCSS\nCascading Style Sheets\n문서를 예쁘게 \u0026ldquo;꾸미는\u0026rdquo; 언어\nJavaScript\nJS = JavaScript\n문서에 \u0026ldquo;기능\u0026quot;을 만들어주는 언어\nHTML - 기본 문법 태그 컨텐츠를 갖는 태그 / 가지지 않는 태그 열리는 태그 \u0026amp; 닫히는 태그 / 단일 태그 (셀프 클로징) \u0026lt;div\u0026gt; contents \u0026lt;/div\u0026gt; / \u0026lt;br /\u0026gt; 속성과 값 \u0026lt;div attributes = value\u0026gt;content\u0026lt;/div\u0026gt; \u0026lt;div title = \u0026quot;제목\u0026quot;\u0026gt; ... title : 전역 속성이라 모든 태그에서 사용 가능 속성(Attributes)의 종류는 아주 많고 다양함 부모요소 \u0026amp; 자식요소 1 2 3 4 html ├─ head │ └─ title └─ body html (부모) - head, body (자식)\n부모/자식 구조를 파악하기 좋게, 들여쓰기/내어쓰기 깊이(depth)를 잘 지켜서 작성해야 함\n탭 잘 쓰라는얘기\nHTML 주석 1 \u0026lt;!-- 주석 내용 --\u0026gt; 1 2 3 \u0026lt;!-- 줄바꿈 가능 --\u0026gt; 1 2 3 4 \u0026lt;!-- \u0026lt;!-- --\u0026gt; --\u0026gt; 이처럼 주석 안에 주석을 넣으면 바깥의 여는 태그가 안쪽 닫는 태그를 인식해 주석이 풀리게 된다. 고로 주석 안에 주석은 X 웹 브라우저의 소스보기 등에서 확인 가능하므로 보안이 필요한 정보는 적지 않아야 한다.\nHEAD 사용자에게는 보이지 않지만, 문서의 정보가 담기는 영역\n타이틀 웹 브라우저 탭이나 창에서 표시되는 문서의 제목 메타 데이터 인코딩 정보 charset(character set) : 문서에서 허용하는 문자의 집합 영어만 허용하는 규칙(ISO-8859-1)을 사용할 경우, 한글은 제대로 출력이 되지 않음 \u0026lt;meta charset = \u0026quot;ISO-8859-1\u0026quot;\u0026gt; utf-8(전 세계 언어 지원) 을 기본으로 사용 문서 설명 \u0026lt;meta name = \u0026quot;description\u0026quot; content = \u0026quot;이 문서는 실습 문서입니다.\u0026quot;\u0026gt; 문서 작성자 \u0026lt;meta name = \u0026quot;author content = \u0026quot;srlee\u0026quot; CSS, Javascript 문서 외형에 영향을 주는 태그들로 구성\nstyle\n1 2 3 4 5 6 \u0026lt;!-- 문서 글자색을 blue로 만드는 코드 --\u0026gt; \u0026lt;style\u0026gt; body { color: blue; } \u0026lt;/style\u0026gt; 길이가 너무 길어지면 작성 및 수정이 불편 -\u0026gt; \u0026lt;link\u0026gt;\nlink\n1 2 3 4 \u0026lt;!--단일 속성 rel: 링크된 파일의 속성 href: 파일 경로 --\u0026gt; \u0026lt;link rel = \u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34; /\u0026gt; 별도로 분리된 CSS파일을 링크\nscript\n콘텐츠 방식\n1 2 3 4 \u0026lt;script\u0026gt; const hello = \u0026#39;world\u0026#39;; console.log(hello) \u0026lt;/script\u0026gt; 링크 방식\n1 2 \u0026lt;!-- 콘텐츠를 가지지 않지만 단일태그는 아니기 때문에 셀프 클로징 X --\u0026gt; \u0026lt;script src = \u0026#34;script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; BODY 사람 눈에 보이는 콘텐츠의 영역\nblock - 블록 레벨 요소 블록처럼 차곡차곡 쌓이며 화면 너비가 꽉 참\n블록의 크기와 내/외부에 여백 지정 가능\n페이지의 구조적 요소\n인라인 요소 포함 가능 / 포함 될 수는 없음\n\u0026lt;div\u0026gt;, \u0026lt;article\u0026gt;, \u0026lt;section\u0026gt;, ...\ninline - 인라인 레벨 요소 블록 요소 내에 포함되는 요소 (블록 요소를 포함할 수 없음!)\n문장, 단어같은 작은 부분에 사용되며, 한 줄에 나열됨\n좌우 여백만 허용\n\u0026lt;span\u0026gt;, \u0026lt;a\u0026gt;, \u0026lt;strong\u0026gt;, ... inline-block 인라인 요소의 불편함을 해결하기 위한 요소 글자처럼 취급되지만 block태그의 성질을 가짐 크기와 내/외부 여백 지정 가능 CSS로 성질을 바꾼 것이기 때문에 의미상 인라인 레벨 요소 활용 예시\n1 2 3 4 \u0026lt;body\u0026gt; \u0026lt;span\u0026gt;인라인\u0026lt;/span\u0026gt; 옆에 글자 \u0026lt;div\u0026gt;블록\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 1 2 3 4 5 6 7 8 9 span{ padding-left: 100px; padding-top: 100px; /* 적용 X */ } div{ padding-top: 50px; padding-bottom: 30px; padding-left: 100px; } Layout Layout Tag? html5부터 태그를 의미있게 사용하기 위해 Semantic태그를 사용하기 시작 div만 사용하지 않고 적절한 태그를 사용해 웹 문서가 담은 정보와 구조를 의미 있게 전달 semantic한 markup -\u0026gt; 검색 엔진의 순위에 가산점, 로딩속도 빨라짐 등 Tags div 가장 흔하게 사용 구역을 나누기 위한 태그 header 제목, 작성일 등 주요 정보를 담는 태그 footer 페이지 바닥줄에 사용, 저작권 정보, 연락처 등 부차적 정보를 담는 태그 main 페이지의 가장 큰 부분으로 내용, 즉 주요 콘텐츠를 담는 태그 한 페이지에 한번만 등장해야 함 (header, footer는 여러번 등장 가능) -section 콘텐츠의 구역을 나누는 태그 article 구역 안에서 작성된 정보를 전달하는 독립적인 문서의 역할을 하는 태그 aside 문서 내용에 부가적인 갖접정보를 전달하는 태그 예) 쇼핑몰의 \u0026lsquo;오늘 본 상품\u0026rsquo;, 블로그의 \u0026lsquo;위젯\u0026rsquo; 등 레이아웃 분석 (배운 내용을 토대로 해본거라 정확하지 않을 수 있습니다) Contents 제목 태그 h1 ~ h6 문서 구획 제목을 나타내는 태그 h1 태그는 페이지 내에 한번만 사용 구획 순서(h1 ~ h6)는 지켜져야 함 문단 태그 p 문단을 담당하는 태그 제목태그와 함께 사용되기도 하고 단독으로도 사용 레이아웃태그처럼 사용 X 서식 태그 b/strong, i/em, u, s/del b/strong : 굵은 글씨로 변경. strong - 강조 의미 부여 i/em : 기울기 조절, em - 기울임과 내용에 강조 의미 부여 u : 밑줄을 넣고 주석을 가짐. 단순히 밑줄만 긋는 용도로는 사용 X s/del : 취소선, del - 문서에서 제거된 텍스트를 나타냄 1 2 3 4 \u0026lt;p\u0026gt; 안녕하세요.\u0026lt;br\u0026gt; \u0026lt;del\u0026gt;섦\u0026lt;/del\u0026gt; \u0026lt;ins\u0026gt;서림\u0026lt;/ins\u0026gt;입니다. \u0026lt;/p\u0026gt; 안녕하세요.\n섦 서림입니다. 링크 이동 a 클릭하면 페이지를 이동할 수 있는 링크 요소\nhref 속성으로 이동하려는 파일 / URL 작성\ntarget 속성으로 새 창(_blank), 현재창(_self)등 타겟 지정 가능\n1 \u0026lt;a href = \u0026#34;https://velog.io/@srlee056\u0026#34; target = \u0026#34;_blank\u0026#34;\u0026gt; 새 창에서 블로그 열기\u0026lt;/a\u0026gt; 새 창에서 블로그 열기\n멀티미디어 img 이미지를 추가하는 태그 src : 이미지의 경로 alt : 로딩에 문제가 발생했을 때 대체 텍스트 alt 태그에 적힌 메세지가 검색엔진에 키워드로 들어감 1 2 \u0026lt;img src = \u0026#34;\u0026#34; alt = \u0026#34;잘못된 로고\u0026#34;\u0026gt; \u0026lt;img src = \u0026#34;https://cdn.icon-icons.com/icons2/2699/PNG/512/python_logo_icon_168886.png\u0026#34; alt = \u0026#34;파이썬 로고\u0026#34;\u0026gt; figure, figcaption 태그 안의 내용을 하나의 독립적인 콘텐츠로 분리하고 설명을 넣을 수 있는 태그\n보통 이미지를 넣으며 인용문, 비디오/오디오 등 문서 흐름에 참조는 되지만 독립적으로 분리되어도 되는 내용을 담는다.\n이미지 - 인라인 레벨 요소 / 피규어 - 블록 레벨 요소\n1 2 3 4 \u0026lt;figure\u0026gt; \u0026lt;img src = \u0026#34;https://www.lgtwins.com/images/emblem/01.emblem.jpg\u0026#34; alt = \u0026#34;엘지 트윈스 로고\u0026#34;\u0026gt; \u0026lt;figcaption\u0026gt; 엘지 트윈스 우승하자! \u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; 엘지 트윈스 우승하자! video 문서 내에 영상을 첨부할 수 있는 태그 src : 비디오 파일이나 온라인 링크 연결 poster : 비디오 로드되기 전 포스터를 보여줄 수 있음 \u0026lt;source\u0026gt; 태그로 여러 타입의 비디오 제공 1 2 3 4 5 6 \u0026lt;video src = \u0026#34;/video.mp4\u0026#34;\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;video poster = \u0026#34;/poster.png\u0026#34;\u0026gt; \u0026lt;source src = \u0026#34;/video.mp4\u0026#34; type = \u0026#34;video/mp4\u0026#34;\u0026gt; \u0026lt;source src = \u0026#34;/video.webm\u0026#34; type = \u0026#34;video/webm\u0026#34;\u0026gt; 비디오 태그가 실행되지 않을 때 보이는 글자 \u0026lt;/video\u0026gt; audio 문서 내에 소리를 첨부할 수 있는 태그\nsrc : 음성 파일이나 온라인 링크 연결\n\u0026lt;source\u0026gt; 태그로 여러 타입의 오디오 제공\ncontrols : 재생/정지 버튼 등이 있는 컨트롤러\n1 2 3 4 5 6 \u0026lt;audio src = \u0026#34;/audio.mp3\u0026#34; controls\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;audio controls\u0026gt; \u0026lt;source src = \u0026#34;/audio.mp3\u0026#34; type = \u0026#34;audio/mp3\u0026#34;\u0026gt; \u0026lt;source src = \u0026#34;/audio.ogg\u0026#34; type = \u0026#34;audio/ogg\u0026#34;\u0026gt; 오디오 태그가 실행되지 않을 때 보이는 글자 \u0026lt;/audio\u0026gt; svg Scalable Vector Graphics\n그래픽으로 만들어진 이미지\n해상도의 영향을 받지 않아 확대/축소 자유로움\n크기를 자주 바꾸어야 하는 작은 아이콘 등에 많이 사용\n최근 기기들은 해상도가 다양하게 변화하고 있어, 아이콘 외에 로고 등 주요 이미지에도 사용\n\u0026lt;img\u0026gt;태그처럼 svg 파일을 불러올수도 있고, 태그를 그대로 사용할수도 있음\n코드로 이루어져 있어서 스타일을 변경하거나, JS를 사용해 기능 추가도 가능\n1 2 3 4 5 6 \u0026lt;img src=\u0026#34;baseball.svg\u0026#34; alt=\u0026#34;야구공 아이콘\u0026#34; /\u0026gt; \u0026lt;!--또는 .svg 파일의 내용을 가져다가 쓸 수 있음--\u0026gt; \u0026lt;svg\u0026gt; 파일 내용 \u0026lt;/svg\u0026gt; svg 파일 출력 결과\n리스트 \u0026lt;ul\u0026gt;, \u0026lt;li\u0026gt;\n순서가 없고 정렬되지 않은 목록\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;list 1\u0026lt;/li\u0026gt; \u0026lt;!--자식 요소로 li만 와야 함--\u0026gt; \u0026lt;li\u0026gt;list 2 \u0026lt;ul\u0026gt; \u0026lt;!-- ul or ol tag--\u0026gt; \u0026lt;li\u0026gt;sub list 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;sub list 2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;sub list 3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; HTML 출력 결과\nlist 1 list 2 sub list 1 sub list 2 sub list 3 \u0026lt;ol\u0026gt;\n순서가 존재하며 정렬된 목록\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;list 1\u0026lt;/li\u0026gt; \u0026lt;!--자식 요소로 li만 와야 함--\u0026gt; \u0026lt;li\u0026gt;list 2 \u0026lt;ol\u0026gt; \u0026lt;!-- ul or ol tag--\u0026gt; \u0026lt;li\u0026gt;sub list 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;sub list 2\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;sub list 3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; HTML 출력 결과\nlist 1 list 2 sub list 1 sub list 2 sub list 3 \u0026lt;dl\u0026gt;, \u0026lt;dt\u0026gt;, \u0026lt;dd\u0026gt;\n설명 목록 태그 \u0026lt;dt\u0026gt;에 작성된 단어 혹은 내용의 설명을 \u0026lt;dd\u0026gt;에 작성 용어사전이나 key-value쌍의 목록을 나타낼 때 사용 \u0026lt;dt\u0026gt; 여러개에 하나의 \u0026lt;dd\u0026gt; 가능 / \u0026lt;dt\u0026gt; 하나에 여러개 \u0026lt;dd\u0026gt; 가능 1 2 3 4 5 6 7 8 9 \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;Chrome\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;웹 브라우저\u0026lt;dd\u0026gt; \u0026lt;dd\u0026gt;구글에서 제작\u0026lt;/dd\u0026gt; \u0026lt;br\u0026gt; \u0026lt;dt\u0026gt;Whale\u0026lt;/dt\u0026gt; \u0026lt;dt\u0026gt;Microsoft Edge\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;Web Browser\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; 표 \u0026lt;table\u0026gt; : 표를 만드는 태그 \u0026lt;tr\u0026gt; 로 행을, \u0026lt;td\u0026gt;로 열을 나타냄 \u0026lt;th\u0026gt; : 열 제목 \u0026lt;thead\u0026gt; : 제목 그룹 태그, 한번만 사용 \u0026lt;tbody\u0026gt; : 표의 본문 요소 그룹 태그, 역시 한번만 사용 \u0026lt;tfoot\u0026gt; : 표 바닥글 요소 태그 \u0026lt;caption\u0026gt; : 표 설명 태그 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;table\u0026gt; \u0026lt;caption\u0026gt;sample table\u0026lt;/caption\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;col 1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;col 2\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;!-- HTML4 에선 tbody 앞--\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;footer\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;footer\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; row1 col1 \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; row1 col2 \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; row2 col1 \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; row2 col2 \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; sample table col 1 col 2 footer footer row1 col1 row1 col2 row2 col1 row2 col2 iframe 현재 문서 안에 다른 HTML 페이지를 삽입하는 역할\nsrc 속성에 원하는 HTML 문서나 URL 전달 name 속성을 지정해 \u0026lt;a\u0026gt; target 속성을 사용해 iframe에서 문서나 URL 열리게 가능 불러온 외부 페이지의 영향을 받을 수 있다. 1 2 3 4 5 \u0026lt;iframe src = \u0026#34;/sample.html\u0026#34; frameborder = \u0026#34;0\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;iframe name=\u0026#34;sample\u0026#34; frameborder=\u0026#34;0\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;a href=\u0026#34;https://example.com/\u0026#34; target=\u0026#34;sample\u0026#34;\u0026gt;example.com\u0026lt;/a\u0026gt; \u0026lt;!--target으로 설정된 iframe에서 외부 페이지가 열림--\u0026gt; 양식 태그 form 정보를 제출하기 위한 태그\n정보 입력을 위한 \u0026lt;input\u0026gt;, \u0026lt;selectbox\u0026gt;, \u0026lt;textarea\u0026gt;\n정보 제출을 위한 \u0026lt;button\u0026gt;\naction 속성 : 정보 제출 시 페이지 이동\nmethod 속성 : 정보 제출 시 처리 방식 결정\nget : 검색 엔진 등에 사용 post : 로그인 등 보안이 중요한 방식에 사용 1 2 3 4 5 6 7 8 9 10 \u0026lt;form action=\u0026#34;form-result.html\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;id\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;select name=\u0026#34;opt\u0026#34;\u0026gt; \u0026lt;option\u0026gt;옵션1\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;옵션2\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;옵션3\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;전송\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; label \u0026lt;input\u0026gt;, \u0026lt;selectbox\u0026gt;, \u0026lt;textarea\u0026gt; 의 설명을 작성하는 태그 for 속성 : 연결하려는 태그의 id속성으로 지정하면 label클릭 시 연결된 태그가 선택됨 label 태그 내부에 input 태그를 넣으면, for-\u0026gt;id 연결을 직접 작성하지 않아도 같은 처리를 해 준다. id 속성값은 절대 중복되면 안됨 1 2 3 4 5 6 7 \u0026lt;label for =\u0026#34;userid\u0026#34;\u0026gt;아이디\u0026lt;/label\u0026gt; \u0026lt;input id = \u0026#34;userid\u0026#34; type = \u0026#34;text\u0026#34; name = \u0026#34;userid\u0026#34;\u0026gt; \u0026lt;label\u0026gt; 비밀번호 \u0026lt;input name = \u0026#34;password\u0026#34; type = \u0026#34;password\u0026#34;\u0026gt; \u0026lt;/label\u0026gt; input 사용자에게 데이터를 입력 받을 수 있는 대화형 태그\ntype 속성 : 받을 수 있는 input 유형을 정함 (기본:text)\nvalue 속성 : 기본 내용을 입력해둘 수 있음\nname : input 이름 지정\n자주 사용되는 input type\ncheckbox radio file button : input 태그를 버튼역할로 사용해야할 때 활용 hidden : 시각적으로 숨겨지지만 정보 제출 시 value속성에 입력된 값은 전송됨 1 2 3 \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;input-name\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value=\u0026#34;입력 내용\u0026#34;\u0026gt; select select, selectbox 옵션 메뉴를 제공하는 태그 option 태그 : 선택할 옵션들을 정의 value 속성 : 제출 시 선택한 옵션의 value값이 전송됨 value 속성을 선언하지 않은 경우엔 option 태그 콘텐츠가 기본값 placehoder 속성 사용 불가 1 2 3 4 5 6 \u0026lt;select name = \u0026#34;selectbox\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;choose\u0026lt;/option\u0026gt; \u0026lt;option value = \u0026#34;opt1\u0026#34;\u0026gt;opt1\u0026lt;/option\u0026gt; \u0026lt;option value = \u0026#34;opt2\u0026#34;\u0026gt;opt2\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;opt3\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; textarea 여러 줄을 입력할 수 있는 대화형 태그 콘텐츠에 내용을 입력할 경우 그 내용이 기본적으로 표시됨 cols/rows 속성 : 기본 너비와 높이를 지정할 수 있으며, 이는 글자 크기 기준으로 정의됨 알아두면 좋은 속성 readonly : 수정 불가능한 읽기 전용 required : form 제출 시 \u0026ldquo;필수 입력 사항\u0026quot;으로 설정 (안내 문구나 행동 등은 브라우저가 자동으로 처리함) placeholder : input, textarea에 부가설명을 입력해둘 수 있으며, select 에는 사용 불가 disabled : 비활성화되어 제출 시 값이 전송되지 않음 button 클릭가능한 버튼 form tag 내 어디서든 사용 가능 type 속성 submit(기본): 양식 제출 reset: 입력 양식 모두 초기화 콘텐츠에 블록레벨을 제외한 태그 입력 가능 disabled 속성 가능 👀 CHECK (어렵거나 새롭게 알게 된 것 등 다시 확인할 것들) vscode -\u0026gt; cmd + , -\u0026gt; folder 검색 -\u0026gt; 계층 구조 관련 옵션 바꿀 수 있음 markup : 설명 블로그 맥에서 크롬 개발자 도구 한번에 키는 단축키 : cmd + shift + c ❗ 느낀 점 HTML문법이나 태그 등에 대한건 이미 알고 있었지만 이론적으로 정리해본 적은 없었기에 이번 강의를 듣고 정리할 수 있어서 좋았다. 특히 contents 태그와 단일 태그의 존재는 알았지만 그 명칭은 몰랐기 때문에 머리속에서 모호하게 정의된 개념들이 이름을 가지고 명확해져서 좋았다.\n강의 내용을 정리하고 직접 실행해보고 궁금한 부분은 따로 찾아보는 등 하다보니 주어진 코어타임보다 훨씬 더 오랜 시간을 붙잡고 있게 되었다. 중간중간 집중력도 떨어지고 체력적으로도 힘든 걸 느끼면서, 이론적인 공부보다는 실제 코드를 작성하는 게 더 재밌다는걸 새삼 체감했다. 그렇지만 이론적인 공부가 전부가 아니더라도 기본적인건 알아야 하니까 재미없다고 등한시 하지는 않아야겠다. :\u0026lt;\n이번주는 드디어 웹 크롤링과 분석을 시작하는데, 내가 해봤던 것과 다른점은 무엇이고 어떤걸 배워나가게 될지 벌써부터 기대가 된다. 내일도 열심히 하는 하루를 보내야겠다. :\u0026gt;\n","date":"2023-10-23T00:00:00Z","permalink":"https://srlee056.github.io/p/day-6/","title":"Day 6"},{"content":"TIL - Heap / Dynamic Programming / DFS\u0026amp;BFS (문제풀이 위주) 📋 공부 내용 Heap \u0026lt;더 맵게\u0026gt; 문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import heapq #heap 라이브러리 사용 def solution(scoville, K): answer = 0 # heapify, heappop, heappush 활용 heapq.heapify(scoville) #min heap 구성 while True: s1 = heapq.heappop(scoville) if s1 \u0026gt;= K : #모든 스코빌 지수가 K이상 break elif len(scoville) == 0: # K이상으로 만들 수 없는 경우 answer = -1 break s2 = heapq.heappop(scoville) newS = s1 + s2*2 heapq.heappush(scoville,newS) answer += 1 return answer Dynamic Programming DP(Dynamic Programming) 알고리즘 진행에 따라 탐색해야 할 범위를 동적으로 결정하여 탐색 범위를 한정\nEX1) 피보나치 수열\nComplexity 재귀함수 DP Time O(2^n) O(n) Space O(n) O(n) 참고 : Recursion vs Dynamic Programming - Fibonacci\nEX2) knapsack problem\nweight / value를 가진 여러 물건이 있을 때, weight 제한이 있는 베낭에 value의 합이 가장 높도록 물건을 골라 담는 문제\n\u0026lt;N으로 표현\u0026gt; 문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def solution(N, number): strN = str(N) # 직관적인 코드를 위해 다음과 같이 index : 1~8 사용 설정 (index 0은 사용하지 않음) numberUsed = [{} for _ in range(9)] for i in range(1, 9): numberUsed[i] = {int(strN * (i))} # N을 i번 나열한 숫자 ex) 555, 7777, ... for j in range(1 , i): for n1 in numberUsed[j]: for n2 in numberUsed[i-j]: newNumbers = [n1*n2, n1+n2, n1-n2] if n2 != 0 : newNumbers.append( n1//n2 ) numberUsed[i].update(newNumbers) #set1.update(set2) 사용하여 원소 추가. set 아닌 list를 넘겨줄수도 있다. if number in numberUsed[i]: return i return -1 DFS \u0026amp; BFS 1. Depth First Search 한 vertex에서 인접한 모든 vertex를 방문할 때, 인접한 vertex를 기준으로 깊이 우선 탐색을 끝낸 후 다음 vertex로 진행하는 방식\n스택을 이용하여 어느 정점에서 DFS를 진행하고 있는지를 기억\n2. Breadth First Search 한 vertex에서 인접한 모든 vertex를 방문하고, 방문한 인접 vertex를 기준으로 너비 우선 탐색을 진행하는 방식\n3. Graph -vertex(=node) \u0026amp; edge(=link)\n-directed / undirected graph\n\u0026lt;여행 경로\u0026gt; 문제 풀이 DFS를 응용한 재귀 한 붓 그리기\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def solution(tickets): routes = {} for a, b in tickets: #출발지, 도착지 routes[a] = routes.get(a, []) routes[a].append(b) for r in routes: routes[r].sort(reverse=True) # 역순인 이유? 파이썬의 데이터 삭제 과정을 살펴보면 뒤에서 뽑는게 더 효울적이기 때문 stack = [\u0026#34;ICN\u0026#34;] path = [] while 0 \u0026lt; len(stack): top = stack[-1] if top not in routes or len(routes[top]) == 0: # 이 공항에서 떠나는 티켓이 존재하지 않음 path.append(stack.pop()) else : stack.append(routes[top].pop()) return path[::-1] 추가 문제풀이 문제 링크 모음(많이 김) 프로그래머스 코딩테스트 문제 링크 (코스에 있는 문제여도 프로그래머스 코테 링크로 적음) 완주하지 못한 사람 올바른 괄호 스킬트리 배달 [세 소수의 합] [주사위 게임] 사탕 담기 [빙고] 방문 길이 [쇠막대기] 자물쇠와 열쇠 [게임 아이템] 기능개발 더 맵게 [배상 비용 최소화] [문자열 압축 코드] 카펫 예산 N-Queen [버스 여행] 예산_소팅 최솟값 만들기 가장 큰 수 N으로 표현 2 x n 타일링 등굣길 가장 긴 팰린드롬 👀 CHECK (어렵거나 새롭게 알게 된 것 등 다시 확인할 것들) PEP 8 파이썬이 추구하는 코드 스타일. 들여쓰기, 공백, 변수명 작성 규칙 등이 포함된다.\nPEP 8 - Style Guide for Python Code(공식 문서) PEP8 스타일 가이드를 설명하는 블로그(한국어) Tim sort Insertion sort + Merge sort\nInsertion sort는 n이 작을 때 (Quick sort보다도) 빠름 전체를 작은 덩어리로 잘라 Insertion sort -\u0026gt; Merge Tim sort에 대해 설명하는 글 DP 익숙해지기 knapsack problem 등 문제풀이를 통해 익숙해지기 ❗ 느낀 점 오늘은 DP(Dynamic Programming)과 DFS\u0026amp;BFS의 개념에 대해 가볍게 배우고, 문제풀이를 위주로 강의가 진행되었다.\n아는 알고리즘들이고 어제 강의의 문제가 나에겐 어렵지 않았기 때문에, 해설 강의를 듣기 전에 문제를 먼저 풀어 보았다. 문제를 풀다가 막히는 부분이 있으면 강의를 틀고, 해결되면 멈추고 다시 풀어보곤 했다.\nHeap 문제를 제외한 두 문제는 해설 없이 풀었고, Heap 문제도 heapq 라이브러리를 사용해야하는 것을 깨닫고는 금방 풀 수 있었다.\n이번주 강의를 듣고 문제를 풀면서 느낀점이 몇개 있다.\n나는 알고리즘 자체는 꽤 잘 알고 활용도 잘 하는 편이지만 라이브러리 사용에 있어서 소극적인 면이 있다. 문제를 풀 때 파이썬 표준 라이브러리조차도 잘 import하지 않고 Dictionary나 Set정도만 사용하는 편이었다. (Heap도 자체적으로 구현하거나 list를 사용하곤 했는데 왜 이런 습관이 들었는지는 잘 모르겠다.) 이번 강의를 들으면서 표준 라이브러리에 있는 여러 데이터형을 활용했고 다음에 문제를 풀 때도 적극적으로 활용하면서 더 효과적인 코드를 작성하는데 가까워지려고 한다.\n나는 CS 용어를 잘 모른다. 아예 모른다는게 아니라, 많이 헷갈리며 정확한 명칭을 찾아보지 않았다는 의미이다. member method, list comprehension 등 용어들은 분명 내가 궁금해서 찾아봤지만 아직도 헷갈리거나 명칭 자체를 몰랐던 것들이다. 강의를 통해 명확해지거나 새롭게 알게 된 용어들이 있어서 좋았고, 이제부터는 모르는 부분에 대해 검색할 때는 아예 용어와 그 정의부터 찾는것부터 시작해야겠다고 다짐했다.\n내일은 강의가 없는 날이다. 하지만 해야 할 일들은 있다. 오늘까지 배운걸 복습하고, 배운 자료구조와 알고리즘을 활용하는 문제들을 lv3정도로 풀어 볼 것이다. 내일도 화이팅!!\n","date":"2023-10-20T00:00:00Z","permalink":"https://srlee056.github.io/p/day-5/","title":"Day 5"},{"content":"TIL - Hash / Greedy \u0026amp; Sort (문제풀이 위주) 📋 공부 내용 Hash Hash?\n개념 정리가 필요하다고 느껴서 글을 따로 발행했다.\nUnderstanding Hash Table\n(번역 및 정리)Hash Table 이해하기\n완주하지 못한 선수 문제풀이\npython dictionary 를 활용하여 hasing 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 def solution(participant, completion): answer = \u0026#39;\u0026#39; pDict = {} # 참가자/ 완주자 정보가 주어질 때, 이름을 key로 활용하여 dictionary 형태에 넣고 빼는 방식으로 # (동명이인이 있을 때에도) 어떤 이름을 가진 사람이 완주를 하지 못했는지 확인할 수 있다. for p in participant: pDict[p] = pDict.get(p, 0) + 1 #.get()을 통해 default 값을 세팅하는 한 방법 for p in completion: pDict[p] -= 1 incompletion = [k for k, v in pDict.items() if v \u0026gt; 0] answer = incompletion[0] return answer Greedy Algorithm 탐욕법(greedy algorithm)\n알고리즘의 각 단계에서 그 순간의 최적의 선택을 함 탐욕법으로 최적해를 찾을 수 있는 문제\n= 현재 선택이 마지막 답의 최적성을 해치지 않는 문제 체육복 문제풀이\n비슷해보이는 조건문이라해도 그 순서에 따라 전혀 다른 결과가 나올 수 있음 작은 번호부터 큰 번호로 순회하기 때문에, 작은 번호가 조건을 만족하는지 먼저 고려함 큰 수 만들기 문제풀이\n매 단계마다 작은 숫자를 지우는 탐욕법을 사용하며, 이 방식은 마지막에 최적성을 충족하게 됨 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def solution(number, k): collected = [] for i, num in enumerate(number): # collected에 미리 들어간 원소가 있을 것 # 제일 마지막으로 들어간 원소는 현재 num 값보다 작을 것 # (제거해야 하는 숫자의 개수) k가 0보다 클 것 while len(collected) \u0026gt; 0 and collected[-1] \u0026lt; num and k \u0026gt;0: collected.pop() k -=1 if k == 0: collected += list(number[i:]) break collected.append(num) # 제거해야 하는 숫자의 개수가 남아있을 때 # (코드가 너무 직관적이고 예뻤다. :\u0026gt;) collected = collected[:-k] if k \u0026gt; 0 else collected answer = \u0026#39;\u0026#39;.join(collected) return answer Sort 가장 큰 수 문제풀이 자릿수가 다른 숫자들을 문자열처럼 나열하여 더 큰 숫자를 만들 때, 숫자들의 우선순위를 정하는 방법은? 1 2 3 4 5 sortedNumbers = sorted(map(str, numbers), key = lambda x : (x * 4)[:4], reverse = True) # map(str, numbers) : numbers 정수 리스트를 문자열 리스트로 변환 # sorted(..., reverse = True) : 주어진 조건으로 정렬하며, 내림차순으로 반환 # lambda x : (x*4)[:4] : 네 자리 수까지 주어지므로 4번 반복 후 네번째자리까지 끊음 👀 CHECK (어렵거나 새롭게 알게 된 것 등 다시 확인할 것들) Hash\n가볍게 정리했지만 더 자세하게 찾아보고 싶음 (활용되는 곳, 특성을 구현하는 법, hashing function, collision 등) list comprehension\n한 줄에 반복문 할당 배열생성 등이 한번에 일어남 list comprehension 설명 블로그 글 쓸 줄 아는 방식이지만 용어를 처음 알게 됨 (예전에 배우고 까먹은 게 분명) list slicing 에 바로 대입하여 직관적으로 코드 작성 가능\nEX) list[1:3] = [1, 2] ❗ 느낀 점 어제 더 나은 코드를 위해 어떤점을 고려해야하는지 많은 고민을 했는데, 오늘 강의에서 그 부분을 짚어줘서 좋았다.\n오늘은 각 알고리즘이나 자료구조에 대한 설명보다는 문제 풀이와 해설을 위주로 강의가 진행되었는데, 그래서 나 스스로 그 개념에 대해 찾아보고 정리하는 시간이 필요했다. greedy나 sort는 이미 잘 알고 있는 부분이지만 hash는 헷갈리는 부분이 있어서 블로그와 document를 읽어보면서 글로 정리하는 시간을 가졌다.\n깊이가 정해져있지 않다 보니 원하는 만큼 궁금해하고 파헤칠 수 있었지만, 내가 그 내용을 받아들이고 정리할 수 있는가는 별개의 문제임을 깨달았다. hash를 설명하는 블로그 글에 연결된 링크를 타고 여러 글을 읽어가다 보니, 어느새 encoding\u0026amp;decoding, scheduling에 대한 글을 읽고 있었다. 이런 글들을 읽고 어느정도 이해할 수는 있었지만, 글로 정리하거나 그 사이의 관계를 명확하게 아는것은 큰 차이가 있었고, 머리속이 혼란스러웠다. 어떤 주제와 관련된 내용을 잘 찾고 정리하는것도 많은 노력이 필요하다는 걸 새삼 느끼는 순간이었다.\n오늘처럼 깊이가 없는 공부를 해야하는 순간은 계속 있을것이고(있어왔고), 정해진 주제에 대해 찾아본 내용들을 글로 정리하면서 나만의 기준을 정립해야겠다는 결론을 내렸다.\n+) 퇴고하기 위해 글을 읽어보는데 두서없고 추상적이라 맘에 들지 않음..(ㅠㅠ) 문장력을 키우고 싶은데 온라인으로도 필사할 수 있는지 찾아봐야겠다.\n","date":"2023-10-19T00:00:00Z","permalink":"https://srlee056.github.io/p/day-4/","title":"Day 4"},{"content":"TIL - Queue, Tree \u0026amp; Heap 📋 공부 내용 Queues Queue?\nFIFO (First In First Out) operations enqueue dequeue 선형 배열으로 구현: O(n) -\u0026gt; 연결 리스트로 구현하는것이 더 좋음 Circular Queues\n배열의 한쪽 끝과 다른쪽 끝이 닿아 있는 모습 원소의 개수가 정해져있음 front / rear 포인터를 기억하고, dequeue된 원소 저장소는 재활용 선형 배열으로 구현하는것이 더 좋음 Priority Queues\n원소들 사이의 우선순위를 따름 우선순위 구현 원소를 넣을 때 enqueue vs. 원소를 꺼낼 때 dequeue 넣을 때(enqueue) 우선순위에 따라 정렬하는것이 조금 더 나은 Time Complexity를 가짐 데이터를 관리하고 활용하는 데에도 더 편리함 Trees Tree?\n구성 root node interner nodes leaf nodes 특성 parent node / child node 노드의 수준 (level) : root node로부터 거리 노드의 차수 (degree) : 노드의 자식 수 트리의 높이(height) 또는 깊이(depth) : 제일 큰 level + 1 subtree Binary Trees\n모든 node의 degree \u0026lt;= 2 operations size() depth() 순회 traversal Depth First Traversal : 재귀 호출을 통해 구현 inorder preorder postorder Breadth Tirst Traversal : queue 사용! level이 낮은 노드를 우선으로 방문 같은 level인 경우 부모 노드의 순서를 따름 포화 이진 트리 (full binary trees) 모든 node의 degree == 2 완전 이진 트리 (complete binary trees) (depth k) level k-2까지는 full binary tree, level k-1은 왼쪽부터 node 채워짐 Binary Search Trees\n모든 노드에 대해 다음 성질을 만족하는 Binary Tree 왼쪽 subtree\u0026rsquo;s data \u0026lt; 현재 node\u0026rsquo;s data \u0026lt; 오른쪽 subtree\u0026rsquo;s data 장단점 장점 : 원소의 추가, 삭제가 편함 단점 : 큰 공간을 소요함 (연결 리스트로 구현) operations insert() remove() lookup() inorder() min(), max() Heap Heaps? Binary Tree의 한 종류 (binary heap)\nMin / Max heap\nroot node가 항상 최소/최대 값을 가진다 complete binary tree n nodes -\u0026gt; depth log(n)+1 insert / remove operation의 Time Complexity : O(log(n)) subtree 또한 Min / Max heap Binary Seacrh Tree vs. Heap?\nBST Heap 데이터 정렬 크기순서대로 완전 정렬 완전 정렬 X 데이터 검색 O X 완전 이진 트리 X O 연산 시간 (최악의 경우) O(n) O(log(n)) 선형 배열로 구현 X O operations\ninsert() remove() 👀 CHECK (어렵거나 새롭게 알게 된 것 등 다시 확인할 것들) 노드의 차수(degree) : # of children binary tree : 모든 노드의 degree가 항상 2이하 leaf nodes : degree 0 단축 평가 단축평가에 대해 참고한 블로그 2개 이상의 논리 조건식이 있을 경우에, 앞 조건이 계산한 값에 의해 결과가 확실해지면 두번째 조건은 확인하지 않음 False and (), True or () 인 경우 등이 해당됨 ❗ 느낀 점 어제의 교훈이 있어서 그런지, 오늘은 프로그래밍 과정에 실수가 적었다. 그리고, 자료구조를 구현하는 과정에서 더 나은 방식에 대해 고민하는 상황이 많아졌다.\n오늘 주로 고민한 부분은\n1 2 3 4 5 코드를 더 직관적으로 적고싶음 - 반복되는 같은 코드를 합칠 수 있는가? 같은 코드 다른 효율? - 같은 기능을 하지만 살짝 다른 두 코드 중 더 나은것은? 정도였다.\n전자는 내가 평소 프로그래밍 할 때 자주 하긴 하는데, 항상 고민하는 부분이다. 반복되는 기능을 함수로 빼던가, 적용되는 변수를 리스트로 묶어서 반복하는 등의 방법을 쓰는데, 다른 방법은 뭐가 있을까 고민하고 있다.\n후자는 Complexity를 구하는 방법에 대한 의문이 아니다. 실제로 이 operation이 어떻게 구현되고 있는지, 왜 그렇게 구현되었는지가 궁금한 것이다. 실습 문제에서 우선순위 queue를 구현할 때, skeleton code의 dequeue 함수는 마지막 elements를 가져오는 방식으로 되어있었다.(getAt(data.size())) 나는 처음 element를 가져오는 방식으로 생각하고(getAt(1)) 이에 해당하는 enqueue 함수를 작성했기 때문에 잠깐 막혔다가, 결국은 눈치채고 해결했다.\n그 코드를 보면서 이렇게 구현하는게 더 나은건지 궁금증이 들었고, 같은 기능을 하지만 결함이 적은(?) 코드를 작성하자는 생각이 들었다.\n오늘은 추가 알고리즘 문제들이 있고 아직 풀지 않았는데, 쉬운 문제들이지만 이 두가지를 생각하면서 풀려고 노력해야겠다.\n","date":"2023-10-18T00:00:00Z","permalink":"https://srlee056.github.io/p/day-3/","title":"Day 3"},{"content":"TIL - LinkedList \u0026amp; Stack 📋 공부 내용 연결 리스트 Linked List 추상적 자료구조 Abstract Data Structures\n내부 구현에는 신경쓸 필요 없는 구조 data \u0026amp; a set of operations 이 두 가지를 추상적으로 보여줌 Linke List?\nNode가 선형적으로 연결된 구조 Node \u0026amp; LinkedList 구현\n1 2 3 4 5 6 7 8 9 10 class Node: def __init__(self, item): self.data = item self.next = None # 다음 노드를 가리킴 class LinkedList: def __init__(self): self.nodeCount = 0 # 노드의 총 갯수 self.head = None # 첫번째 노드 self.tail = None # 마지막 노드 Linked List 연산 (operations)\nlinked list의 index는 1부터 시작 / 0은 다른 용도로 사용(Dummy node)\n(실습으로 구현한 코드만 첨부했음) kth element 참조\n리스트 순회\n1 2 3 4 5 6 7 def traverse(self): curr = self.head returnList = [] while curr is not None: returnList.append(curr.data) curr = curr.next return returnList 길이 얻기\n원소 삽입\nTime complexity 맨 앞에 삽입 : O(1) 중간에 삽입 : O(n) 맨 끝에 삽입 : (Tail pointer가 있기 때문에) O(1) 원소 삭제\nTime complexity 맨 앞에 삽입 : O(1) 중간에 삽입 : O(n) 맨 끝에 삽입 : O(n) → 이 상황을 피하기 위해 이중 연결 리스트를 사용 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 삭제한 node 데이터를 반환 def popAt(self, pos): if pos \u0026lt; 1 or pos \u0026gt; self.nodeCount: raise IndexError if pos == 1: prev = None curr = self.head self.head = curr.next else: prev = self.getAt(pos - 1) curr = prev.next prev.next = curr.next if pos == self.nodeCount: self.tail = prev self.nodeCount -= 1 return curr.data 두 리스트 합치기 concat\n배열 Array vs 연결 리스트 Linked List\n배열 연결 리스트 저장 공간 연속된 위치 임의의 위치 특정 원소 참조 매우 간편 선형탐색과 유사 O(1) O(n) time complexity에 불리함이 있는데도 사용하는 이유는?\n연결 리스트 Linked List의 힘\n유연한 삽입 및 삭제 Head, Tail에 dummy node를 추가하여 간편하고 직관적인 설계 가능 추가 구현 operations insertAfter(prev, node)\npopAfter(prev) \u0026amp; popAt(pos)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def popAfter(self, prev): curr = prev.next if curr is None : return None if curr.next is None: self.tail = prev prev.next = curr.next self.nodeCount -= 1 # nodeCount 꼭 체크하기 return curr.data def popAt(self, pos): if pos \u0026lt; 1 or pos \u0026gt; self.nodeCount: raise IndexError prev = self.getAt(pos-1) return self.popAfter(prev) 양방향 / 이중 연결 리스트 Double Linked List 양쪽으로 연결된 link - next node, previous node로 두 방향 모두 진행 가능 - 메모리 사용량이 늘어나지만, 앞에서뿐만 아니라 뒤에서도 데이터를 찾아갈 수 있다는게 장점 getAt() 함수 또한 pos가 중간값 이상일 때는 뒤에서부터 찾도록 구현할 수 있음 operations reverse\n1 2 3 4 5 6 7 def reverse(self): result = [] curr = self.tail while curr.prev.prev: curr = curr.prev result.append(curr.data) return result insertBefore\n1 2 3 4 5 6 7 8 def insertBefore(self, next, newNode): prev = next.prev newNode.next = next newNode.prev = prev prev.next = newNode next.prev = newNode self.nodeCount += 1 return True popAfter, popBefore, popAt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def popAfter(self, prev): curr = prev.next next = curr.next prev.next = next next.prev = prev self.nodeCount -= 1 return curr.data def popBefore(self, next): curr = next.prev prev = curr.prev prev.next = next next.prev = prev self.nodeCount -= 1 return curr.data def popAt(self, pos): if pos \u0026lt; 1 or pos \u0026gt; self.nodeCount: raise IndexError prev = self.getAt(pos - 1) return self.popAfter(prev) # next = self.getAt(pos+1) # getAt 함수가 pos == nodeCount+1 일 때 지원을 하지 않아서 사용은 어려움 # next = self.getAt(pos).next #로 사용 가능 # return self.popBefore(next) concat(self, L)\n1 2 3 4 5 6 7 def concat(self, L): lastNode = self.tail.prev firstNode = L.head.next lastNode.next = firstNode firstNode.prev = lastNode self.tail = L.tail self.nodeCount += L.nodeCount 스택 Stack data element를 보관할 수 있는 선형 구조 / LIFO operations size() isEmpty() push(x) 꽉 찬 스택에 push(x)로 원소를 더 추가하려고 할 때 stack overflow 발생 pop() 비어있는 스택에서 pop()으로 없는 원소를 꺼내려 할 때 stack underflow 발생 peek() 데이터 참조, 제거하지는 않음 추상적 자료구조로 구현 Array 또는 LinkedList 이용 만들어져있는 Stack library 를 import 할 수도 있음 from pythonds.basic.stack import Stack 스택의 응용 1) 후위 표기법으로 변환\n중위 표기법 (infix notation) : (A+B) * (C+D) → 후위 표기법 (postfix notation) : AB+CD+* 알고리즘 설계 operator 연산자를 스택에 넣는 방식\n연산자 우선순위 설정\n1 prec = {\u0026#39;*\u0026#39;:3, \u0026#39;/\u0026#39;:3, \u0026#39;+\u0026#39;:2, \u0026#39;-\u0026#39;:2, \u0026#39;(\u0026#39;:1} 구현 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def solution(S): opStack = ArrayStack() charList = [] # 수식을 리스트 형태로 저장한 후 .join을 통해 문자열로 변환 for s in S: if s in prec.keys(): # 연산자 + 여는 괄호 if s == \u0026#34;(\u0026#34;: opStack.push(s) else: while not opStack.isEmpty(): # 스택이 비어있는 동안 계속 if prec[opStack.peek()] \u0026gt;= prec[s]: # 스택 맨 위의 우선순위가 높거나 같은 경우에만 charList.append(opStack.pop()) # pop()하여 문자열에 출력 else: break opStack.push(s) elif s == \u0026#34;)\u0026#34;: # 닫는 괄호 while opStack.peek() != \u0026#34;(\u0026#34;: # 여는 괄호가 나올때까지 모든 연산자를 꺼내 출력 charList.append(opStack.pop()) opStack.pop() # pop \u0026#39;(\u0026#39; else: # 피연산자 charList.append(s) while not opStack.isEmpty(): # 스택에 남아있는 연산자들을 모두 출력 charList.append(opStack.pop()) answer = \u0026#34;\u0026#34;.join(charList) return answer 스택의 응용 2) 후위 표기법 계산\n앞에서부터 뒤로 읽어나가면서 먼저 만나는 연산자를 먼저 계산 알고리즘 설계 operands 피연산자들을 스택에 넣는 방식\n구현 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def postfixEval(tokenList): valStack = ArrayStack() for t in tokenList: if type(t) is int: valStack.push(t) else: b = valStack.pop() a = valStack.pop() if t == \u0026#39;*\u0026#39;: valStack.push(a*b) elif t == \u0026#39;/\u0026#39;: valStack.push(a/b) elif t == \u0026#39;+\u0026#39;: valStack.push(a+b) elif t == \u0026#39;-\u0026#39;: valStack.push(a-b) return valStack.pop()\t👀 CHECK (어렵거나 새롭게 알게 된 것 등 다시 확인할 것들) member field, member method\n용어의 뜻은 알지만 애매해서 다시 정리하기 위해 찾아봄 정리에 참고한 사이트 추상적 자료구조\nabstract data type vs. data structure an ADT (Abstract Data Type) is more of a logical description, while a Data Structure is concrete. 정리에 참고한 사이트 : 추상적 자료형 vs. 자료구조 dummy node를 추가한 구조의 linked list\nstack underflow\n‼️ 느낀 점 오늘은 두 가지 교훈(?) 을 얻었다.\n한번에 두가지 일을 하지 않기 강의를 들으면서 TIL을 적으려고 했는데, 외려 더 정신없고 힘들었다. 강의 듣는 중간에 적다 보니, 그냥 받아쓰기가 되는것도 별로였다. 큰 주제 (오늘 같은 경우 LinkedList / Stack)를 다 듣고 정리하는게 나을 듯!\n사소한 실수 하지 않고 꼼꼼하게 체크하기 오늘 연습문제를 풀면서\nnode.data 대신 node 객체를 반환함 linked list의 nodeCount 증감시키는걸 빼먹음\n명시된 조건을 빼먹는 실수를 저질러서 디버깅 한다고 다 합해서 한시간 가까이 소모했다. 몰라서 못 푸는것 보다 이런 부분에서 꼼꼼하지 못해서 못 푸는게 더 싫다. 심지어 원래는 그렇게 자주 하는 실수도 아니어서 자존심이 더 상했다. ㅠㅠ 그래도 이런 날이 있어야 앞으로 안 그럴 수 있으니까 계속 담아두지는 말아야지!\n내일은 강의와 실습을 꼼꼼하게 진행하고, 내가 이해한 내용을 토대로 TIL을 잘 적어봐야겠다. :\u0026gt;. 그리고 내일은 github 블로그에 올려봐야지! 🔥 어렵지만 할 만한 가치가 있어보인다 😊\n","date":"2023-10-17T00:00:00Z","permalink":"https://srlee056.github.io/p/day-2/","title":"Day 2"},{"content":"1일차 TIL에서 이어지는 블로그 제작기 입니다. :\u0026gt;\n(아직 제작중인)블로그를 구경하시려면 클릭하세요!\n1. 로컬에서 휴고 사이트 만들기 1 2 3 4 5 6 hugo new site blog cd blog git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack echo \u0026#34;theme = \u0026#39;hugo-theme-stack\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml hugo server 나는 가이드에 적힌 theme과는 다른 hugo-theme-stack을 사용했다. 가이드에는 새 post를 만들고 config 파일인 hugo.toml을 수정하는 부분도 나와있지만, 이후에 둘 다 다른 내용으로 덮어써서 넘어가도 되는 과정이었다.\n2. theme 커스터마이징하기 themes/hugo-theme-stack/exampleSite/config.yaml 파일 내용을 변환하여 제일 상위 폴더의 ./hugo.toml 파일에 붙여넣고,\n(구글에 \u0026lsquo;yaml to toml\u0026rsquo;로 검색하면 많은 converter를 볼 수 있다.)\nthemes/hugo-theme-stack/exampleSite/contetns/ 안의 파일들을 ./contetns 에 붙여넣었다.\n이 과정에는 이 블로그 글을 많이 참고했다. 정말 감사합니다👍🏻\nhugo.toml 파일에 오류가 좀 있는 것 같지만\n내가 아직 hugo configuration 관련해서 잘 모르고 오류가 있는데도 서버가 잘 돌아가고 빌드도 돼서 나중에 고치기로 했다. (🤔 이게 왜 되지?) 3. 배포하기 (사실 배포가 제일 쉬웠다) github 사이트에서 \u0026lt;username\u0026gt;.github.io 이름의 레포지토리를 만들고 로컬에서 변경 내용을 모두 commit한 이후,\n1 git remote add origin https://github.com/\u0026lt;username\u0026gt;/\u0026lt;username\u0026gt;.github.io.git 위 커맨드를 입력해 로컬과 원격 레포지토리를 연결한다. 1 git push -u origin master 그리고 push하면 레포지토리 관련은 끝. (branch 관련 건드린 게 있다면 push하기 전에 master로 옮길것.) +) 요즘은 master가 아닌 main branch로 바뀌었더라. 빌드와 배포는 git actions기능을 활용했는데, hugo 사이트에 github hosting 가이드라인이 잘 적혀있다.\n이 링크의 내용을 요약하자면\n레포지토리 settings/pages에서 source를 GitHub Actions로 변경 로컬에서 .github/workflows/hugo.yaml 파일 생성 후 내용 붙여넣기 (폴더도 직접 생성해줘야함) 변경사항을 commit, push한 이후 레포지토리의 Actions 탭에 들어가면 빌드/배포 기능을 하는 Action이 추가됨 Run Workflow 버튼을 누르면 빌드/배포가 자동으로 진행되며 내 github page에 테마가 적용된 사이트가 잘 올라와 있다. 왜인지 모르겠지만 잘 돌아가는 블로그\n블로그 github repo.\n느낀점 전체적으로 해결하지 못한 오류도 많고, 이해하지 못한 구조도 많지만 오늘은 배포에 성공한 것에 의의를 두려고 한다.🥲\n다음엔? hugo로 포스트 올리기 오류 해결하기 (layout 인식 문제 등) theme custom 으로 링크 등 UI 추가해보기 ","date":"2023-10-16T00:00:00Z","permalink":"https://srlee056.github.io/blog-1/","title":"Blog 제작기 #1"},{"content":"1. 자료구조 \u0026amp; 알고리즘 강의 및 코드 리뷰 📋 공부 내용 선형 배열 - Linear Arrays 배열(array) : 개념적 구조 / 리스트 : python 데이터형\n리스트 methods\ntime complexity O(1) .append() .pop() time complexity O(n) .insert() .del() .index() .insert() 정렬(sort)\nsorted() : function, 정렬된 새로운 리스트를 반환하며 기존 리스트에는 변화 없음. .sort() : method, 기존 리스트가 정렬됨 숫자가 아닌 문자열 등 데이터형의 정렬 : 사전순이 기본, 문자열의 길이 등 다른 정렬 조건을 사용하고 싶다면 lambda 활용 문자열을 길이순으로 정렬\n1 sorted(L, key = lambda x : len(x)) 사전 데이터형(dictionary)에 key = ‘name’인 value의 문자열 순서대로 정렬\n1 2 3 L = [ {\u0026#39;name\u0026#39; : \u0026#39;John\u0026#39;, \u0026#39;score\u0026#39;: 90}, {\u0026#39;name\u0026#39; : \u0026#39;Paul\u0026#39;, \u0026#39;score\u0026#39;: 80} ] sorted(L, key = lambda x : x[\u0026#39;name\u0026#39;] 탐색(search)\n선형(linear) 탐색, 순차(sequential) 탐색 이진(binary) 탐색 재귀 알고리즘 - recursive algorithms 종결 조건(trivial case) 을 명시해야 함 예시 1부터 x까지 숫자의 합을 구하는 함수 (sum)\n1 2 3 def recursiveSum(x): if x \u0026lt; 1 : return x return recursiveSum(x-1) + x 조합의 수 (nCm)\n하노이의 탑\n피보나치 순열\n장점 : 알고리즘을 간단하고 이해하기 쉽게 풀어냄 단점 : time complexity 부분에서 비효율적인 경우가 많음 이러한 특성 때문에 tree 자료구조를 이용하는 알고리즘에 활용 Complexity Time Complexity Space Complexity 다루는 데이터가 커질수록, 더 효율적인 complexity를 가지는 방식이 필요함 (2^n, n! 등의 complexity X) 👀 CHECK (어렵거나 새롭게 알게 된 것 등 다시 확인할 것들) 코드로 elapsed time을 확인 -\u0026gt; 디버깅이나 time complexity를 직관적으로 확인하는 등에 활용 list method .pop() 과 .remove()의 차이점 big O notation - O of n 으로 읽음 list의 앞과 뒤에 접근하는것은 O(1)의 time complextity를 갖는다. ‼️ 느낀 점 아직까지는 전공 과정 복습하는 느낌이고, 쉽다고 느꼈다. 막히는 부분은 없었다. 코드를 작성하면서 조금 더 나은 코드에 대해 생각해보는것 정도. 공부하는 중이나 이후에 바로 TIL을 적는게 제일 좋다고 생각하는데, 블로그 세팅에 정신이 팔려서 나중에 작성하게 된 건 조금 아쉽다. 오늘은 코어타임보다 일찍 강의를 들어버려서 시간 분배가 애매했다. 내일은 코어타임 시작할 때 듣기 시작하고, 그 전에는 전날 내용을 복습하거나, 알고리즘 문제를 풀고 code review를 작성하는 시간을 가져야겠다.\n2. 블로그 세팅 과정 노션이나 옵시디언으로 TIL을 적고 깃에 업로드 한 적은 많지만 블로그에 올리는건 처음이라, 어디에 올리지 고민하다가 일단 티스토리 계정과 블로그를 만들었다.\n그런데 만들다 보니 github repo와 연동되는 page를 세팅하고 싶다..! 라는 욕심이 들기 시작했고, jekyll 등을 알아보다가 hugo를 활용한 페이지 세팅을 접하게 되어 장장 3시간을 투자했다.\n그런데 이 글을 티스토리에 올리는 이유는? 세팅에 실패했기 때문 ㅠㅠ\nTIL 작성하고 나서 다시 도전해서 세팅 과정에 대해서도 글을 써 볼 예정이다.\n+) 티스토리에서 md로 작성한게 예쁘게 안나와서 벨로그로 옮겼다 😂 훨씬 편한 것 같은데 깃허브랑 연동 전까진 벨로그로 해야겠다 :\u0026gt;\n(지금까지 참고한 링크들) 휴고 사이트 생성 가이드 휴고 사이트 깃허브 연결 가이드 사용 테마1 사용 테마2 ","date":"2023-10-16T00:00:00Z","permalink":"https://srlee056.github.io/p/day-1/","title":"Day 1"}]